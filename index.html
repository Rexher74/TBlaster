<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css">
    <title>Ushoot</title>
    <style>
        body {
            margin: 0;
            background-image: url("./backgroundIMG.jpg");
        }
    </style>
</head>
<body>
    <canvas id="canv"></canvas>
    <script>
        // UTILITIES
        function min(a, b) {
            if (a > b) return b;
            else return a;
        }

        function getRandomColor() { // ChatGPT
            // Definir un rango mínimo para que los colores sean brillantes (evitando valores cercanos a 0)
            const rangoMinimo = 100; // Mínimo para evitar colores oscuros
            const rangoMaximo = 255; // Máximo permitido
          
            // Generar componentes RGB dentro del rango
            const rojo = Math.floor(Math.random() * (rangoMaximo - rangoMinimo + 1)) + rangoMinimo;
            const verde = Math.floor(Math.random() * (rangoMaximo - rangoMinimo + 1)) + rangoMinimo;
            const azul = Math.floor(Math.random() * (rangoMaximo - rangoMinimo + 1)) + rangoMinimo;
          
            // Retornar el color en formato RGB
            return `rgb(${rojo}, ${verde}, ${azul})`;
        }

        function adjustProbabilities(probabilities, rate = 0.01) { // ChatGPT
            const adjusted = [...probabilities];
            const n = adjusted.length;
          
            // Redistribute probabilities
            for (let i = 0; i < n; i++) {
              if (i === 0) {
                // Reduce probability for the weakest enemy
                adjusted[i] -= rate;
              } else {
                // Increase probability for stronger enemies
                adjusted[i] += rate / (n - 1);
              }
            }
          
            // Ensure no probability goes below 0
            for (let i = 0; i < n; i++) {
              if (adjusted[i] < 0) {
                adjusted[i] = 0;
              }
            }
          
            // Normalize probabilities to sum to 1
            const sum = adjusted.reduce((acc, val) => acc + val, 0);
            return adjusted.map(p => p / sum);
          }

        function getSpawningPos(radio) { // ChatGPT
            // Elegir un borde aleatorio (0 = arriba, 1 = abajo, 2 = izquierda, 3 = derecha)
            const borde = Math.floor(Math.random() * 4);
          
            let x, y;
          
            switch (borde) {
              case 0: // Arriba
                x = Math.random() * window.innerWidth; // Posición horizontal aleatoria
                y = -radio; // Tangente al borde superior
                break;
          
              case 1: // Abajo
                x = Math.random() * window.innerWidth; // Posición horizontal aleatoria
                y = window.innerHeight + radio; // Tangente al borde inferior
                break;
          
              case 2: // Izquierda
                x = -radio; // Tangente al borde izquierdo
                y = Math.random() * window.innerHeight; // Posición vertical aleatoria
                break;
          
              case 3: // Derecha
                x = window.innerWidth + radio; // Tangente al borde derecho
                y = Math.random() * window.innerHeight; // Posición vertical aleatoria
                break;
            }
          
            return { x, y };
        }

        function getScoreVariation(r, radioMin, radioMax, scoreMax, scoreMin) { // ChatGPT
            // Fórmula de interpolación lineal
            const score = scoreMax - ((r - radioMin) / (radioMax - radioMin)) * (scoreMax - scoreMin);
            return score;
          }

        function collision(x1, y1, r1, x2, y2, r2) {
            let distance = Math.sqrt(Math.pow(x1-x2, 2) + Math.pow(y1-y2, 2));
            return distance <= r1+r2;
        }

        function getRandomLevel() {
            let randNum = Math.random();
            let idxLvl = 0;
            while (randNum > PROBABILITY_LEVEL[idxLvl]) {
                randNum-=PROBABILITY_LEVEL[idxLvl];
                ++idxLvl;
            }
            return idxLvl;
        }

        // EVENT LISTENERS
        window.addEventListener("resize", (function() {
            iniGame();
            CONFIG.CENTERX = window.innerWidth/2;
            CONFIG.CENTERY = window.innerHeight/2;
            CONFIG.SIZE_CENTER_PX = min(window.innerWidth, window.innerHeight)*CONFIG.SIZE_CENTER/100;
            CONFIG.MARGIN_ORBIT_PX = min(window.innerWidth, window.innerHeight)*CONFIG.MARGIN_ORBIT/100;
        }));

        window.addEventListener("pointerdown", function() {
            if (gs.canShoot()) {
                gs.updateNewShoot();
                for (const pointer of pointers) {
                    let dirx = Math.cos(pointer.angle);
                    let diry = Math.sin(pointer.angle);
                    bullets.push(new Bullet(pointer.x, pointer.y, dirx, diry));
                }
                STATE.DIRECTION*=-1;
            }
            
        })

        class Pointer {
            constructor(angle = 0) {
                this.angle = angle;
                this.x = CONFIG.CENTERX + (CONFIG.SIZE_CENTER_PX+CONFIG.MARGIN_ORBIT_PX)*Math.cos(this.angle);
                this.y = CONFIG.CENTERY + (CONFIG.SIZE_CENTER_PX+CONFIG.MARGIN_ORBIT_PX)*Math.sin(this.angle);
            }

            move() {
                this.angle += STATE.POINTER_SPEED*STATE.DIRECTION;
                this.x = CONFIG.CENTERX + (CONFIG.SIZE_CENTER_PX+CONFIG.MARGIN_ORBIT_PX)*Math.cos(this.angle);
                this.y = CONFIG.CENTERY + (CONFIG.SIZE_CENTER_PX+CONFIG.MARGIN_ORBIT_PX)*Math.sin(this.angle);
                this.print();
            }

            print() {
                c.beginPath();
                c.shadowBlur = CONFIG.MBLUR;
                c.shadowColor = CONFIG.MCOLOR;
                c.fillStyle = CONFIG.MCOLOR;
                c.arc(this.x, this.y, CONFIG.SIZE_CENTER_PX*STATE.POINTER_SIZE/100, 0, 2*Math.PI);
                c.fill();
            }

            setAngle(newAngle) {
                this.angle = newAngle;
            }
        }

        class Bullet {
            constructor(x, y, dirx, diry) { // dirx and diry must be unit vectors
                this.x = x;
                this.y = y;
                this.dirx = dirx;
                this.diry = diry;
                this.radius = CONFIG.SIZE_CENTER_PX*STATE.POINTER_SIZE/100;
            }

            move() {
                this.x += this.dirx*STATE.SPEED_BULLETS;
                this.y += this.diry*STATE.SPEED_BULLETS;
                this.print();
            }

            print() {
                c.save();
                c.beginPath();
                c.shadowBlur = CONFIG.MBLUR;
                c.shadowColor = CONFIG.MCOLOR;
                c.fillStyle = CONFIG.MCOLOR;
                c.arc(this.x, this.y, this.radius, 0, 2*Math.PI);
                c.fill();
                c.restore();
            }

            isOutOfCanvas() {
                return this.x-this.radius > canvas.width || this.x+this.radius < 0
                        || this.y-this.radius > canvas.height || this.y+this.radius < 0
            }
        }

        class Enemy {
            constructor(x, y, radius, level) {
                this.x = x;
                this.y = y;
                this.color = COLOR_LEVEL[level];
                this.radius = radius;
                this.level = level;
                this.speedX = (CONFIG.CENTERX-this.x)/STATE.SPEED_ENEMIES;
                this.speedY = (CONFIG.CENTERY-this.y)/STATE.SPEED_ENEMIES;
            }

            move() {
                this.x += this.speedX;
                this.y += this.speedY;
                this.print();
            }

            print() {
                c.save();
                c.beginPath();
                c.shadowBlur = this.color;
                c.shadowColor = this.color;
                c.fillStyle = this.color;
                c.arc(this.x, this.y, this.radius, 0, 2*Math.PI);
                c.fill();
                c.restore();
            }

            reduceLives() {
                --this.level;
                if (this.level < 0) return true;
                this.color = COLOR_LEVEL[this.level];
                this.radius *= CONFIG.RADIUS_REDUCTION_LEVEL;
                return false;
            }

            arrived() {
                return Math.sqrt(Math.pow(CONFIG.CENTERX-this.x, 2) + Math.pow(CONFIG.CENTERY-this.y, 2)) <= CONFIG.SIZE_CENTER_PX+this.radius;
            }
        }

        class GameState {
            constructor(iniLives) {
                this.lives = iniLives;
                this.score = 0;
                this.shooted = 0;
                this.hit = 0;
                this.ss = 50000; // in mili shoots (1 shoot == 1000 mili shoots)
            }

            print() {
                c.font='25px FontAwesome';
                c.fillStyle = "white";
                c.textAlign = "center";
                c.shadowBlur = 0;
                c.fillText(`\uF004 ${this.lives}    \uF005 ${this.score}    \uf140 ${Math.round(this.hit*100/this.shooted || 0)}%`, CONFIG.CENTERX, CONFIG.MARGIN_TOP_STATS);
                this.printSS();
            }

            printSS() {
                c.save();
                c.lineWidth = 4;
                c.strokeStyle = "#ea5353";
                c.fillStyle = "#ea5353";
                c.beginPath();
                c.rect(window.innerWidth*7/16, window.innerHeight-40, window.innerWidth*2/16, 10);
                c.stroke();
                c.lineWidth = 0;
                c.beginPath();
                c.rect(window.innerWidth*7/16, window.innerHeight-40, (window.innerWidth*2/16)*(this.ss/(CONFIG.MAX_SHOOTS_STORAGE*1000)), 10);
                c.fill();
                c.restore();
            }

            updateScore(variation) {
                this.score += variation;
            }

            updateLives(variation) {
                this.lives+=variation;
            }

            reduceLive() {
                this.updateLives(-1);
            }

            increaseLive() {
                this.updateLives(1);
            }

            increaseShooted() {
                this.shooted++;
            }

            increaseHit() {
                this.hit++;
            }

            incrementMS() {
                let newMS = this.ss+STATE.SHOOTS_PER_FRAME*1000;
                if (newMS <= CONFIG.MAX_SHOOTS_STORAGE*1000) this.ss = newMS;
                else this.ss = CONFIG.MAX_SHOOTS_STORAGE*1000;
            }

            canShoot() {
                return this.ss >= 1000;
            }

            updateNewShoot() {
                this.ss -= 1000;
            }
            
        }

        // MAIN

        var canvas = document.getElementById("canv");
        var c = canvas.getContext("2d");

        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        var CONFIG = {
            INI_LIVES: 5,
            CENTERX: window.innerWidth / 2,
            CENTERY: window.innerHeight / 2,
            SIZE_CENTER: 5, // min(SIZE_CENTER vw, SIZE_CENTER vh)
            MARGIN_ORBIT: 2, // min(MARGIN_ORBIT vw, MARGIN_ORBIT vh)
            MCOLOR: "#ffffff",
            MBLUR: 10,
            MARGIN_TOP_STATS: 40, // px
            INCREASE_DIFFICULTY_PERIOD: 10000, // ms
            SCORE_BASE_MAX: 100, // Score earned if enemy with size STATE.RADIUS_ENEMY_MIN eliminated
            SCORE_BASE_MIN: 20, // Score earned if enemy with size STATE.RADIUS_ENEMY_MAX eliminated
            DECREASE_PERIOD_SPAWNING: 0.95, // new_period = old_period*DECREASE_PERIOD_SPAWNING
            RADIUS_REDUCTION_LEVEL: 0.9,
            ADJUST_PROBABILITIES_RATE: 0.01,
            MAX_SHOOTS_STORAGE: 50,
            INC_SHOOTS_PER_FRAME: 1.01 // every CONFIG.INCREASE_DIFFICULTY_PERIOD seconds
        }
        CONFIG.SIZE_CENTER_PX = min(window.innerWidth, window.innerHeight)*CONFIG.SIZE_CENTER/100;
        CONFIG.MARGIN_ORBIT_PX = min(window.innerWidth, window.innerHeight)*CONFIG.MARGIN_ORBIT/100;

        var STATE = {
            DIRECTION: 1,
            POINTER_SPEED: 0.03,
            POINTER_SIZE: 20, // % of SIZE_CENTER
            SPEED_BULLETS: 10, // px / iteration
            SPAWNING_PERIOD: 2000, // in ms
            RADIUS_ENEMY_MAX: 2.5, // Proportion with CONFIG.SIZE_CENTER_PX (1 means RADIUS_ENEMY_MAX = CONFIG.SIZE_CENTER_PX)
            RADIUS_ENEMY_MIN: 0.4, // Proportion with CONFIG.SIZE_CENTER_PX (1 means RADIUS_ENEMY_MAX = CONFIG.SIZE_CENTER_PX)
            SPEED_ENEMIES: 1000, // Iterations of requestAnimationFrame to arrive to the center
            SCORE_GOAL: 6000, // Score after with you get a new pointer. It doubles every time archived
            SHOOTS_PER_FRAME: 0.0275 // num. shoots earned per second
        }

        const COLOR_LEVEL = ["#7eff00", "#00ffd1", "#00b2ff", "#2a00ff", "#b600ff", "#ff00a6", "#ff0000", "ff8f00", "#ffe800", "#fff7b6"];
        var PROBABILITY_LEVEL = [0.4, 0.25, 0.15, 0.07, 0.05, 0.03, 0.021, 0.013, 0.009, 0.007];

        var bullets = [];
        var enemies = [];
        var pointers = [];
        var GameOver = false;
        var intervalSpawning;
        var intervalIncreaseDifficlty;

        function init() {
            iniGame();
            step();
            iniSpawning();
            iniIncreaseDifficultySpawning();
        }

        function gameOver() {
            GameOver = true;
            clearInterval(intervalSpawning);
            alert("Game Over!");
        }

        function iniGame() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            c.clearRect(0, 0, innerWidth, innerHeight);
            setCenter();
        }

        function setCenter() {
            c.beginPath();
            c.shadowBlur = CONFIG.MBLUR;
            c.shadowColor = CONFIG.MCOLOR;
            c.fillStyle = CONFIG.MCOLOR;
            c.arc(CONFIG.CENTERX, CONFIG.CENTERY, CONFIG.SIZE_CENTER_PX, 0, 2*Math.PI);
            c.fill();
        }

        function step() {
            c.clearRect(0, 0, innerWidth, innerHeight);
            setCenter();
            let numBullets = bullets.length;
            for (let i = numBullets-1; i >= 0; --i) {
                bullets[i].move();
                if (bullets[i].isOutOfCanvas()) {
                    bullets.splice(i, 1);
                    gs.increaseShooted();
                    continue;
                }
                
                // Check collision with enemies
                let nEnemies = enemies.length;
                for (let j = nEnemies-1; j >= 0; --j) {
                    if (collision(bullets[i].x, bullets[i].y, bullets[i].radius, enemies[j].x, enemies[j].y, enemies[j].radius)) {
                        let scoreVariance = getScoreVariation(enemies[j].radius, STATE.RADIUS_ENEMY_MIN*CONFIG.SIZE_CENTER_PX,
                                                            STATE.RADIUS_ENEMY_MAX*CONFIG.SIZE_CENTER_PX, CONFIG.SCORE_BASE_MAX, CONFIG.SCORE_BASE_MIN);
                        gs.updateScore(Math.round(scoreVariance));
                        if (gs.score > STATE.SCORE_GOAL) {
                            addNewPointer();
                            STATE.SCORE_GOAL*= 2;
                        }
                        if (enemies[j].reduceLives()) enemies.splice(j, 1);
                        bullets.splice(i, 1);
                        gs.increaseHit();
                        gs.increaseShooted();
                        break;
                    }
                }

            }
            let numEnemies = enemies.length;
            for (let i = numEnemies-1; i >= 0; --i) {
                enemies[i].move();
                if (enemies[i].arrived()) {
                    enemies.splice(i, 1);
                    gs.reduceLive();
                    if (gs.lives <= 0) gameOver();
                }
            }
            gs.print();
            gs.incrementMS();
            for (let i = 0; i < pointers.length; i++) {
                pointers[i].move();
            }
            if (!GameOver) requestAnimationFrame(step);
        }

        function spawn() {
            let maxRad = CONFIG.SIZE_CENTER_PX*STATE.RADIUS_ENEMY_MAX;
            let minRad = CONFIG.SIZE_CENTER_PX*STATE.RADIUS_ENEMY_MIN;
            let radius = Math.random()*(maxRad-minRad)+minRad;
            let {x, y} = getSpawningPos(radius);
            let level = getRandomLevel();
            enemies.push(new Enemy(x, y, radius, level));
        }

        function iniSpawning(period) {
            intervalSpawning = setInterval(spawn, STATE.SPAWNING_PERIOD);
        }

        function iniIncreaseDifficultySpawning() {
            intervalIncreaseDifficlty = setInterval(function() {
                clearInterval(intervalSpawning);
                STATE.SPAWNING_PERIOD*=CONFIG.DECREASE_PERIOD_SPAWNING;
                iniSpawning(STATE.SPAWNING_PERIOD);
                PROBABILITY_LEVEL = adjustProbabilities(PROBABILITY_LEVEL, CONFIG.ADJUST_PROBABILITIES_RATE);
                STATE.SHOOTS_PER_FRAME*=CONFIG.INC_SHOOTS_PER_FRAME;
            }, CONFIG.INCREASE_DIFFICULTY_PERIOD);
        }

        function addNewPointer() {
            let numNewPointers = pointers.length+1;
            pointers = []; // clear the array
            let divisionSize = Math.random()*2/numNewPointers; // 2 is a arbitrary number to make Math.random() bigger
            for (let i = 0; i < numNewPointers; i++) {
                pointers.push(new Pointer(i*divisionSize));
            }

        }

        // GAME INICIALIZATION
        pointers.push(new Pointer());
        var gs = new GameState(CONFIG.INI_LIVES);

        init();

    </script>
</body>

</html>